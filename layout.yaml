# layout.yaml

---

# rules for layout, appearance, computed, shortcuts:
#
#     - name:
#       - no self. prefix
#       - use shortcut name rather than expanded name
#     - in exp:
#       - don't use self. prefixes 
#       - use child.attr to lookup an attr in child after it's created, and child__attr to get a
#         copy of the value sent to the child ctor
#       - can use shortcut names


# layout:
#     layout defines argument defaults for layout arguments.  These are only passed to __init__ and
#     never change.  The defaults end up as parameter defaults, so must be legal in that context.
#
#     width and height are used.
#
# appearance:
#     appearance defines argument defaults for appearance arguments.  These are passed to both
#     __init__ and draw, so may change (by draw).
#     The defaults end up as parameter defaults, so must be legal in that context.
#
# shortcuts:
#     defines shortcut names that are used for parameter names to make it easier for callers to set
#     important parameters.
#
# for drawing:
#     width and height are used.
#
# for touch:
#     touch_width and touch_height are used.  They default to width and height.

module: shapes

import:
    - import math
    - import os.path
    - from pyray import *
    - import screen
    - from alignment import half
    - import sprite

include: |
    Fonts = []   # Serif, Serif-Bold, Sans, Sans-Bold
    Font_names = []

    @screen.register_init
    def init_fonts(screen_obj):
        # This must run _after_ init_window is called!

        global Fonts, Font_names
        # Load Fonts:
        for name in 'Serif', 'Sans':
            for bold in False, True:
                font_name = "DejaVu" + name
                if bold:
                    font_name += '-Bold'
                path = os.path.join(screen.Font_dir, font_name + ".ttf")
                Font_names.append(font_name)
                font = load_font(path)
                #print(f"{font=}, {is_font_valid(font)=}")
                Fonts.append(font)

    class as_dict(dict):
        def __init__(self, attrs):
            self.attrs = attrs

        def __getitem__(self, key):
            try:
                return getattr(self.attrs, key)
            except AttributeError:
                raise KeyError(key)

    class gap:
        def __init__(self, name="a gap", height=0, width=0):
            self.name = name
            self.height = height
            self.width = width

        def draw(self, x_pos=None, y_pos=None):
            pass

    class vgap(gap):
        def __init__(self, margin, name="a vgap"):
            super().__init__(name, height=margin)

        def __repr__(self):
            return f"<vgap({self.name})={self.height}>"

    class hgap(gap):
        def __init__(self, margin, name="an hgap"):
            super().__init__(name, width=margin)

        def __repr__(self):
            return f"<hgap({self.name})={self.width}>"

widget_stubs:
    vgap:
        layout: [margin]
    hgap:
        layout: [margin]

add_to_all: [Fonts, Font_names, vgap, hgap]


static_text:

    trace:
        - variable.init
        - translate_name
        - translate_exp
        - show_shortcuts
        - show_layout
        - show_appearance
        - show_computed_init
        - show_computed_draw
        - show_init_params
        - show_init_available
        - show_draw_params
        - show_draw_available
        - show_draw_computable
        - method__init__dump

    raylib_call:
        name: draw_text_ex
        args: [font, str(text), (x_left.i, y_top.i), size, spacing, color]
    layout:
        size: 20
        spacing: 0
        sans: false
        bold: false
        text: null
    appearance:
        color: BLACK
    computed:
        init:
            font: Fonts[2 * sans + bold]
            msize: measure_text_ex(font, str(text), size, spacing)
            width: int(math.ceil(msize.x))
            height: int(math.ceil(msize.y))

dynamic_text:
    raylib_call:
        name: draw_text_ex
        args: [font, str(text), (x_left.i, y_top.i), size, spacing, color]
    layout:
        size: 20
        spacing: 0
        sans: false
        bold: false
        max_text: null
    appearance:
        color: BLACK
        text: null
    computed:
        init:
            font: Fonts[2 * sans + bold]
            msize: measure_text_ex(font, str(max_text), size, spacing)
            width: int(math.ceil(msize.x))
            height: int(math.ceil(msize.y))
        draw:
           #cooked_text: str_text.format_map(as_dict(self))
            draw_msize: measure_text_ex(font, text, size, spacing)
            draw_width: int(math.ceil(draw_msize.x))
            draw_height: int(math.ceil(draw_msize.y))
    include:
        init: |
            self.sprite = sprite.Sprite(self.width, self.height, trace=self.trace)
        draw_before: |
            self.sprite.save_pos(self.x_pos, self.y_pos)
        clear: |
            self.sprite.reset()

rect:
    raylib_call:
        name: draw_rectangle

        # nice if width and height are odd, gives integer center
        args: [x_left.i, y_top.i, width, height, color]
    layout:
        width: null
        height: null
    appearance:
        color: WHITE

circle:
    raylib_call:
        name: draw_circle
        args: [x_center.i, y_middle.i, radius, color]
    layout:
        diameter: 31  # nice if this is odd, gives integer radius

        # used by touch_buttons:
        min_touch_radius: 28        # ok even or odd
        #min_touch_diameter: 57
        touch: null
    appearance:
        color: WHITE

        # used by touch_buttons:
        on_color: GREEN    # suggest: RED, GREEN, BLUE
        off_color: BROWN   # suggest: GRAY, DARKGRAY, BROWN, BLACK
    computed:
        init:
            radius: half(diameter)
            width: diameter
            height: diameter
            touch_radius: max(radius, min_touch_radius)
    include:
        init: |
            if self.touch is not None:
                self.touch.attach_widget(self)
        draw_end: |
            if self.touch is not None:
                self.touch.activate()
        clear: |
            if self.touch is not None:
                self.touch.deactivate()

---

module: containers

import:
    - from pyray import *
    - from shapes import *

bordered_circle:
    stacked:
        elements:
            - border: circle
            - body: circle
    layout:
        diameter: 31
        border_width: 2             # or, maybe, 3 -- ok even or odd
        touch: null
    appearance:
        border__color: BLACK
        color: WHITE
        on_color: GREEN
        off_color: BROWN
    shortcuts:
        diameter: border__diameter  # nice if this is odd, gives integer radius
        color: body__color
        on_color: body__on_color
        off_color: body__off_color
        touch: body__touch
    computed:
        init:
            body__diameter: border__diameter - 2*border_width

titled:
    trace:
        - show_init_params
        - show_draw_params
    column:
        elements:
            - top: vgap
            - title_text: static_text
            - middle: vgap
            - body: placeholder
            - bottom: vgap
    layout:
        title: '"title"'
        top__margin: 5     # above title
        middle__margin: 3  # between title and body
        bottom__margin: 7  # below body
    shortcuts:
        title: title_text__text

boxed:
    stacked:
        elements:
            - border: rect
            - background: rect
            - body: placeholder
    layout:
        border_width: 2             # width of outer border line
        horz_margin: null           # between body and left/right edge of background
        vert_margin: null           # between body and top/bottom edge of background
    appearance:
        border__color: BLACK
        color: WHITE
    shortcuts:
        color: background__color
    computed:
        init:
            horz_margin: border_width
            vert_margin: border_width
            border__width: background__width + 2*border_width
            border__height: background__height + 2*border_width
            background__width: body__width + 2*horz_margin
            background__height: body__height + 2*vert_margin

boxed_titled:
    trace:
        - show_init_params
        - create_widget_args
    specializes: boxed
    placeholders:
        body:
            - body_titled: titled
    layout:
        title: '"title"'
        placeholders: null
    appearance:
        color: WHITE
    shortcuts:
        title: body_titled__title
        placeholders: body_titled__placeholders

spp_text:
    specializes: dynamic_text
    layout:
        max_text: '"888-8.8"'
    appearance:
        color: BLACK
        text: '"1.1"'

spp_display:
    specializes: boxed_titled
    placeholders:
        body:
            - text: spp_text
    layout:
        title: '"title"'
    appearance:
        color: WHITE

spp_mark:
    specializes: boxed_titled
    placeholders:
        body:
            - text: spp_text
            - gap: vgap
            - mark: bordered_circle
    layout:
        title: '"title"'
        gap__margin: 3
    appearance:
        color: WHITE
    computed:
        init:
            bordered_circle__touch: null  # FIX

---

module: slider

import:
    - import math
    - from pyray import *
    - from alignment import half
    - from shapes import *
    - from containers import *
    - import sprite
    - from touch import touch_slider

include: |
    def longer_str(a, b):
        a = str(a)
        b = str(b)
        if len(a) > len(b):
            return a
        return b

    def id(x):
        return x

    # m = (max_y - min_y) / (max_x - min_x)
    # b = min_y - m*min_x       # m*min_x + b = min_y

    # so m*max_x + b = max_y ?
    #    m*max_x + min_y - m*min_x = max_y ?
    #    m*(max_x - min_x) = max_y - min_y
    #    m = (max_y - min_y) / (max_x - min_x)
    def linear(m, b):
        # y = m*x + b
        digits = max(0, int(math.ceil(-math.log(m, 10) - 1e10)))  # after decimal point
        def scalei(x):  # returns an int
            return round(m*x + b)
        def scalef(x):  # returns a float
            return round(m*x + b, digits)
        if digits <= 0:
            return scalei
        return scalef

    # min_y*math.pow(m, max_x) = max_y
    # math.pow(m, max_x) = max_y / min_y
    # m = math.pow(max_y / min_y, 1/max_x) # raise each side by 1/max_x
    def exponential(m, min):
        # y = min*math.pow(m, x)
        digits_at_min = max(0, int(math.ceil(-math.log(min*(m-1), 10) - 1e10)))  # after decimal point
        breakpoints = [math.ceil(math.pow(10, -d) / (m - 1))
                       for d in range(digits_at_min, -1, -1)] 
        assert breakpoints[0] < min, f"{breakpoints[0]=} >= {min=}"
        del breakpoints[0]
        def scale(x):
            ans = min*math.pow(m, x)
            i = 0
            while i < len(breakpoints) and breakpoints[i] < ans:
                i += 1
            digits = digits_at_min - i
            if digits <= 0:
                return round(ans)
            return round(ans, digits)
        return scale

slider_vknob:
    stacked:
        elements:
            - wide_rect: rect
            - narrow_rect: rect
    layout:
        as_sprite: true
    appearance:
        wide_rect__color: BLACK
        narrow_rect__color: GRAY
    computed:
        init:
            wide_rect__width: 49
            wide_rect__height: 19
            narrow_rect__width: 61
            narrow_rect__height: 5
    include:
        init: |
            self.sprite = sprite.Sprite(self.width, self.height, trace=self.trace)
        draw_before: |
            self.sprite.save_pos(self.x_pos, self.y_pos)
        clear: |
            self.sprite.reset()

slider_touch:
    stacked:
        elements:
            - centerline: rect
            - knob: slider_vknob
    layout:
        low_value: 0
        high_value: 127
        tick: 3  # width of a "tick", or the number of pixels separating one value from the next
        centerline__width: 3
        touch: null
        scale_fn: id
    appearance:
        centerline__color: BLACK
    computed:
        init:
            num_values: (high_value - low_value) + 1
            slide_height: (num_values - 1) * tick
            centerline__height: slide_height + knob.height - 1
       #draw:
       #    slide_y_top_C: (y_top + half(knob.height)).as_C()        # knob Y_pos at high_value
       #    slide_y_bottom_C: (y_bottom - half(knob.height)).as_C()  # knob Y_pos at low_value
    include:
        init: self.touch.attach_widget(self)
        draw_end: |
            y_top = y_pos.S(self.height)
            y_bottom = y_pos.E(self.height)

            # knob Y_pos at high_value
            self.slide_y_top_C = (y_top + half(self.knob.height)).as_C()

            # knob Y_pos at low_value
            self.slide_y_bottom_C = (y_bottom - half(self.knob.height)).as_C()

            self.touch.activate()
        clear: self.touch.deactivate()

slider:
    trace:
        - variable.init
        - translate_name
        - translate_exp
        - show_shortcuts
        - show_layout
        - show_appearance
        - show_computed_init
        - show_init_params
        - show_init_available
        - method__init__dump
    specializes: boxed_titled
    placeholders:
        body:
            - display: dynamic_text
            - slider_gap: vgap
            - slider: slider_touch
    layout:
        title: null
        low_value: 0
        high_value: 127
        tick: 3  # number of pixels separating one value from the next
        scale_fn: id
        slider_gap__margin: 5
        command: null
    shortcuts:
        low_value: slider__low_value
        high_value: slider__high_value
        tick: slider.tick
        scale_fn: slider__scale_fn
    computed:
        init:
            display__max_text: longer_str(scale_fn(low_value), scale_fn(high_value))
            display__text: str(scale_fn(low_value))
            slider__touch: touch_slider(name, display, scale_fn, command)

