# layout.yaml

---

touch:
    needs:
        - contains(x, y)
        - touch(x, y)
        - move_to(x, y)
        - release

operation:  # overall operation of program
    data:
        read: nothing special
        write: [who, value]  # who may be None if it's not a listener.
        listen: who  # may have multiple listeners.  Listener not activated when it writes.
        examples:
            cc_param:
                channel: may be int or channels object
                param: int
                value: this is the data
                to_text: fn to generate text for display
                listeners:
                    midi: send CC MIDI command for each channel
                    display: update display (text or slide position)
                updaters:
                    midi: on received CC MIDI command
                    display: on user input
            change_spp: sends MIDI STOP & SPP commands
            stop: sends MIDI STOP command
            start: sends MIDI START command
            continue: sends MIDI CONTINUE command
            channels:
                values: 0-15
                multivalued: true
                humans: add one
            chord_nums:
                values: 0-5
                multivalued: true
            slur_position:  # factors into CC param
                values: [start, end]
                multivalued: true
            spp:
                updated_by: MIDI CLOCK
                read_only: true
                to_text: fn to generate text for display
    action:
        - update display values
        - change display layout, load_panel (registers for touch), unload_panel (clears touch)
        - change player CC params
        - change SPP
        - stop
        - start
        - continue

---

# rules for layout, appearance, computed, shortcuts:
#
#     - name:
#       - no self. prefix
#       - use shortcut name rather than real name
#     - in exp:
#       - don't use self. prefixes 
#       - use obj.attr rather than obj__attr
#       - can use shortcut names


# layout:
#     layout defines argument defaults for layout arguments.  These are only passed to __init__ and
#     never change.  The defaults end up as parameter defaults, so must be legal in that context.
#
#     width and height are used.
#
# appearance:
#     appearance defines argument defaults for appearance arguments.  These are passed to both
#     __init__ and draw, so may change (by draw).
#     The defaults end up as parameter defaults, so must be legal in that context.
#
# shortcuts:
#     defines shortcut names that are used for parameter names to make it easier for callers to set
#     important parameters.
#
# for drawing:
#     width and height are used.
#
# for touch:
#     touch_width and touch_height are used.  They default to width and height.

module: foobar

import:
    - import math
    - import os.path
    - from pyray import *
    - import screen

include: |
    Fonts = []   # Serif, Serif-Bold, Sans, Sans-Bold
    Font_names = []

    @screen.register_init
    def init_fonts(screen_obj):
        # This must run _after_ init_window is called!

        global Fonts, Font_names
        # Load Fonts:
        for name in 'Serif', 'Sans':
            for bold in False, True:
                font_name = "DejaVu" + name
                if bold:
                    font_name += '-Bold'
                path = os.path.join(screen.Font_dir, font_name + ".ttf")
                Font_names.append(font_name)
                font = load_font(path)
                #print(f"{font=}, {is_font_valid(font)=}")
                Fonts.append(font)

    class as_dict(dict):
        def __init__(self, attrs):
            self.attrs = attrs

        def __getitem__(self, key):
            try:
                return getattr(self.attrs, key)
            except AttributeError:
                raise KeyError(key)

    class gap:
        def __init__(self, name="a gap", height=0, width=0):
            self.name = name
            self.height = height
            self.width = width

        def draw(x_pos=None, y_pos=None):
            pass

    class vgap(gap):
        def __init__(self, name="a vgap", margin):
            super.__init__(self, name, height=margin)

        def __repr__(self):
            return f"<vgap({self.name})={self.height}>"

    class hgap(gap):
        def __init__(self, name="an hgap", margin):
            super.__init__(self, name, width=margin)

        def __repr__(self):
            return f"<hgap({self.name})={self.width}>"

widget_stubs:
    vgap:
        layout: [margin]
    hgap:
        layout: [margin]

add_to_all: [Fonts, Font_names, vgap, hgap]


text:
    #trace_draw: true
    raylib_call:
        name: draw_text_ex
        args: [font, cooked_text, position, size, spacing, color]
    layout:
        size: 20
        spacing: 0
        sans: false
        bold: false
        max_text: null
    appearance:
        color: BLACK
        text: null
    computed:
        init:
            font: Fonts[2 * sans + bold]
            msize: measure_text_ex(font, max_text or text, size, spacing)
            width: int(math.ceil(msize.x))
            height: int(math.ceil(msize.y))
        draw:
            cooked_text: str(text).format_map(as_dict(self))
            position: x_left.i, y_top.i
            draw_msize: measure_text_ex(font, cooked_text, size, spacing)
            draw_width: int(math.ceil(draw_msize.x))
            draw_height: int(math.ceil(draw_msize.y))

rect:
    #trace_init: true
    raylib_call:
        name: draw_rectangle

        # nice if width and height are odd, gives integer center
        args: [x_left, y_top, width, height, color]
    layout:
        width: null
        height: null
    appearance:
        color: WHITE

circle:
    raylib_call:
        name: draw_circle
        args: [x_center, y_middle, radius, color]
    layout:
        diameter: 31  # nice if this is odd, gives integer radius
    appearance:
        color: WHITE
    computed:
        init:
            radius: half(diameter)
            width: diameter
            height: diameter

---

module: containers

bordered_circle:
    #trace_init: true
    stacked:
        elements:
            - border: circle
            - body: circle
    layout:
        diameter: 31
        border_width: 2             # ok even or odd
        min_touch_radius: 28        # ok even or odd
        #min_touch_diameter: 57
    appearance:
        color: WHITE
        border__color: BLACK
    shortcuts:
        diameter: border__diameter  # nice if this is odd, gives integer radius
        color: body__color
    computed:
        init:
            radius: half(border__diameter)
            body__diameter: border__diameter - 2*border_width
            touch_radius: max(radius, min_touch_radius)
    contains(x, y): |4
        dist = math.sqrt((x - x_center)**2 + (y - y_middle)**2)
        return dist <= self.touch_radius

titled:
    #trace_init: true
    column:
        elements:
            - top: vgap
            - title: text
            - middle: vgap
            - body: placeholder
            - bottom: vgap
    layout:
        title: "title"
        top__margin: 5     # above title
        middle__margin: 3  # between title and body
        bottom__margin: 7  # below body
    shortcuts:
        title: title__text

boxed:
    #trace_init: true
    stacked:
        elements:
            - border: rect
            - background: rect
            - body: placeholder
    layout:
        border_width: 2             # width of outer border line
        horz_margin: border_width   # between body and left/right edge of background
        vert_margin: border_width   # between body and top/bottom edge of background
    appearance:
        border__color: BLACK
        color: WHITE
    shortcut:
        color: background__color
    computed:
        init:
            border__width: background__width + 2*border_width
            border__height: background__height + 2*border_width
            background__width: body__width + 2*horz_margin
            background__height: body__height + 2*vert_margin

boxed_titled:
    #trace_init: true
    template: boxed
    arguments:
        body:                      # placeholder name in boxed
            - titled: titled       # titled body placeholder becomes boxed_titled placeholder
    layout:
        title: "title"
    shortcuts:
        title: titled__title

spp_text:
    refines: text
    layout:
        max_text: "888-8.8"
    appearance:
        text: "1.1"

spp_display:
    template: boxed_titled
    arguments:
        body:
            - spp_text: spp_text

spp_mark:
    skip: true
    column:
        elements:
            - spp_text: spp_text
            - gap: vgap
            - mark: button
    layout:
        gap__margin: 3

spp_mark2:
    skip: true
    template: boxed_titled
    arguments:
        body:
            - spp_text: spp_text
            - gap: vgap
            - mark: button
    layout:
        gap__margin: 3

spp_boxed_mark:
    skip: true
    template: boxed_titled
    arguments:
        body:
            - spp_mark: spp_mark
    # ...
